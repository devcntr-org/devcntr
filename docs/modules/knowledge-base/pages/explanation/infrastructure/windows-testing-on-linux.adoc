= Testing Windows Builds on Linux
:description: An overview of strategies for testing Windows-specific software, scripts, and installers while developing on a Linux host.

When developing software for Windows on a Linux machine, testing is the most significant hurdle. While cross-compilation is relatively straightforward, runtime validation—especially for installers, drivers, and system-level scripts—requires a high-fidelity Windows environment.

This page explores the landscape of Windows testing on Linux, ranging from lightweight compatibility layers to near-native virtualization.

== Testing Strategies Landscape

The choice of environment depends on the "depth" of the Windows features your software interacts with.

[cols="1,2,2", options="header"]
|===
| Method | Best For | Limitations

| **Real Windows VM (KVM/QEMU)**
| Installers (MSI/MSIX), PowerShell scripts, Win32 APIs, Registry edits, Services.
| Requires more system resources than other methods.

| **Compatibility Layers (Wine/Proton)**
| CLI tools, basic Win32 apps, simple installers.
| Fails on deep system components like drivers, COM registration, or Windows Update.

| **CI Pipelines (GitHub/GitLab)**
| Automated smoke tests, build validation, packaging.
| No interactive debugging; slow feedback loop.

| **Cloud Instances (Azure/AWS)**
| High-performance testing, specific hardware needs.
| Recurring costs; requires internet connectivity.
|===

== Virtualization: The Gold Standard

For developers building installers or system utilities, a dedicated **KVM/QEMU Virtual Machine** is the only reliable way to ensure "first-run" success for users.

=== Why Virtualization Wins
* **Snapshots:** Revert the entire OS to a "clean" state in seconds. This is critical for testing installers that modify the registry or system files.
* **Deterministic Behavior:** A real Windows kernel handles .NET quirks, Windows Update, and System32 behavior exactly like a user's machine.
* **Automation:** Tools like the QEMU Guest Agent (QGA) allow the Linux host to execute commands inside the guest and capture output programmatically.

== Hybrid Workflows

The most efficient modern workflow involves **building on Linux and testing on Windows**.

1. **Cross-compile:** Use MinGW, Zig, Rust, or .NET to produce Windows binaries on your Linux host.
2. **Synchronize:** Use `virtiofs` or `rsync` over SSH to move artifacts into a running Windows VM.
3. **Automate:** Trigger a snapshot revert, run the installer, and capture the result via CLI automation.

== Repeating and Disposing

For high-volume testing, use **Windows Sandbox** inside your Windows VM. This provides a "sandbox within a box"—once you close the sandbox, every change is discarded without needing to manage VM snapshots manually.

See also: xref:how-to/kvm-windows-automation.adoc[How to Automate Windows Testing via KVM]
